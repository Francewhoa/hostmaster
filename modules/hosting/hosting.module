<?php

/**
 * @file
 *   Hosting module.
 *
 * Contains just about all the interface magic of hostmaster.
 */

/**
 * Not split for performance reasons. Just to keep code together.
 */
//include_once('hosting.inc');
//include_once('hosting.queues.inc');
include_once('hosting.features.inc');

/**
 * Implements hook_menu().
 */
function hosting_menu() {
  $items = array();

  $items['hosting/disabled'] = array(
    'title' => 'Site disabled',
    'page callback' => 'hosting_disabled_site',
    'access arguments' => array('access disabled sites'),
    'type' => MENU_CALLBACK
  );

  $items['hosting/maintenance'] = array(
    'title' => 'Site maintenance',
    'page callback' => 'hosting_site_maintenance',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );

  $items['admin/config/hosting'] = array(
    'title' => 'Hosting',
    'description' => 'Configure and manage the hosting system',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_features_form'),
    'access arguments' => array('administer hosting'),
    'type' => MENU_NORMAL_ITEM
  );

  $items['admin/config/hosting/features'] = array(
    'title' => 'Features',
    'description' => 'Configure the exposed functionality of the Hosting system',
    'weight' => -100,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_features_form'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer hosting features'),
  );

  $items['admin/config/hosting/queues'] = array(
    'title' => 'Queues',
    'description' => 'Configure the frequency that cron, backup and task events are process',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_queues_configure'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer hosting queues'),
    'file' => 'hosting.admin.inc',
  );

  $items['admin/config/hosting/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure general Hosting settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_settings'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer hosting settings'),
    'file' => 'hosting.admin.inc',
  );

  $items['hosting/queues'] = array(
     'page callback' => 'hosting_queues',
     'type' => MENU_CALLBACK,
     'access arguments' => array('access task logs')
   );

  return $items;
}

/**
 * Implementats hook_menu_alter().
 */
function hosting_menu_alter(&$items) {

  $items['node/add']['page callback'] = '_hosting_node_add';

  $types = hosting_feature_node_types(TRUE);
  foreach ($types as $feature => $type) {
    $path = sprintf('node/add/%s', str_replace('_', '-', $type));
    $items[$path]['access callback'] = 'hosting_menu_access';
    $items[$path]['access arguments'] = array(str_replace('_', ' ', $type), $feature);
  }

  // These node types should remain hidden, and provide no user interface.
  unset($items['node/add/package']);
  unset($items['node/add/task']);

}

/**
 * Menu access callback for creating a node provided by a Hosting feature.
 *
 * @param $type
 *   The node type that the user wants to create.
 * @param $feature
 *   The machine name of the host feature that should be additionally checked to
 *   see if it's enabled.
 * @return
 *   TRUE if the user can access, FALSE otherwise.
 */
function hosting_menu_access($type, $feature) {
  global $user;
  return  (($user->uid == 1) || user_access('create ' . $type)) && (hosting_feature($feature) != HOSTING_FEATURE_DISABLED);
}

/**
 * Page callback for a site that has been disabled.
 */
function hosting_disabled_site() {
  drupal_set_breadcrumb(array());
  return t("This site has been disabled by the site administrators");
}

/**
 * Page callback for a site that is undergoing maintenance.
 */
function hosting_site_maintenance() {
  drupal_set_breadcrumb(array());
  return t("This site is currently in maintenance. Check back later.");
}

/**
 * Implements hook_node_presave().
 */
function hosting_node_presave($node) {
  global $user;
  if (in_array($node->type, hosting_context_node_types()) && !isset($node->uid)) {
    $node->uid = $user->uid;
  }
}

/**
 * Implements hook_node_delete().
 */
function hosting_node_delete($node) {
  if (in_array($node->type, hosting_context_node_types())) {
    db_delete('hosting_context')
      ->condition('nid', $node->nid)
      ->execute();
  }
}

/**
 * Implements hook_node_load().
 */
function hosting_node_load($nodes, $types) {
  if (count(array_intersect($types, hosting_context_node_types()))) {
    $result = db_query('SELECT name FROM {hosting_context} WHERE nid IN(:nids)', array(':nids' => array_keys($nodes)));
    foreach ($result as $record) {
      $nodes[$record->nid]->hosting_name = $record->name;
    }
  }
}

/**
 * Implements hook_permission().
 */
function hosting_permission() {
  return array(
    'access hosting wizard' => array(
      'title' => t('Access hosting wizard'),
    ),
    'administer hosting queues' => array(
      'title' => t('Administer hosting queues'),
    ),
    'administer hosting features' => array(
      'title' => t('Administer hosting features'),
    ),
    'administer hosting' => array(
      'title' => t('Administer hosting'),
    ),
    'access disabled sites' => array(
      'title' => t('Access disabled sites'),
    ),
    'administer hosting settings' => array(
      'title' => t('Administer hosting settings'),
    ),
  );
}

/**
 * Per node type description text. To be stored in the node_type table.
 *
 * @todo Move this out to the modules that implement the nodes.
 *
 * @param $type
 *   The node type.
 * @return
 *   Description text for the node type.
 */
function hosting_node_help($type) {
  switch ($type) {
    case 'site' :
      return t("<strong>An instance of a hosted site.</strong>
                It contains information relating to the site, most notably the domain name, database server
                and platform it is being published on. A site may also have several aliases for additional
                domains the site needs to be accessible on.");
      break;
    case 'platform' :
      return t("<strong>The file system location on a specific web server on which to publish sites.</strong>
                Multiple platforms can co-exist on the same web server, and need to do so for
                upgrades to be managed, as this is accomplished by migrating the site between platforms.
                Platforms are most commonly built for specific releases of Drupal.");
      break;
    case 'client' :
      return t("<strong>The person or group that runs the site.</strong>
                This information is usually required for billing and access purposes, to ensure
                that only certain people are able to view the information for sites they run.
                If you do not intend on having more than one client access the system,
                you will not need to create any additional clients for your purposes.");
      break;
    case 'server' :
      return t("<strong>The physical machine which will provide various services to your site.</strong>
                Each server can have multiple services associated to it. To host a site you require a database service and a web service, which can either be provided by a single or multiple servers.");
      break;
    case 'task' :
      return t("<strong>The mechanism whereby Hostmaster keeps track of all changes that occur to the system.</strong>
                Each task acts as a command for the back-end, and contains a full log of all changes that have occurred.
                If a task should fail, the administrator will be notified with an explanation of exactly what went wrong,
                and how to fix it.");
      break;
  }
}

/**
 * Implements hook_init().
 */
function hosting_init() {
  // Definitions for the default platforms, clients etc.
  // Done to avoid using 'magic numbers'
  define('HOSTING_DEFAULT_CLIENT', variable_get('hosting_default_client', 1));
  define('HOSTING_DEFAULT_DB_SERVER', variable_get('hosting_default_db_server', 2));
  define('HOSTING_DEFAULT_WEB_SERVER', variable_get('hosting_default_web_server', 3));

  /**
   * This client has access to everything, see hosting_client.access.inc
   */
  define('HOSTING_ADMIN_CLIENT', variable_get('hosting_admin_client', 1));

  define('HOSTING_OWN_DB_SERVER', variable_get('hosting_own_db_server', 2));
  define('HOSTING_OWN_WEB_SERVER', variable_get('hosting_own_web_server', 3));
  define('HOSTING_OWN_PLATFORM', variable_get('hosting_own_platform', 6));


  /**
   * Find the base URL, this is used by the initial 'hosting-setup' drush command
   * This gets defined in the bootstrap, so just using the global definition.
   */
  define('HOSTING_DEFAULT_BASE_URL', $GLOBALS['base_url']);
}

/**
 * Implementation of hook_theme().
 */
function hosting_theme() {
  return array(
    'hosting_queues_configure' => array(
      'file' => 'hosting.admin.inc',
      'arguments' => array(
        'form' => NULL,
      ),
    ),
  );
}

function _hosting_node_link($nid, $title = null) {
  if (is_null($nid)) {
    return t("None");
  }
  $node = node_load($nid);
  $title = (!is_null($title)) ? $title : filter_xss($node->title);
  if ($node->nid) {
    return node_access('view', $node) ? l($title, "node/" . $node->nid) : filter_xss($node->title);
  }
}

/**
 * Implements hook_block_info().
 */
function hosting_block_info() {
  $blocks['hosting_summary'] = array(
    'info' => t('Hosting summary'),
    'cache' => DRUPAL_NO_CACHE, // DRUPAL_CACHE_PER_ROLE is the default
    'enabled' => 1,
    'region' => 'left',
    'weight' => 10,
  );

  $blocks['hosting_queues'] = array(
    'info' => t('Hosting queues'),
    'cache' => DRUPAL_NO_CACHE, // DRUPAL_CACHE_PER_ROLE is the default
    'enabled' => 1,
    'region' => 'right',
    'weight' => 0,
  );

  $blocks['hosting_queues_summary'] = array(
    'info' => t('Hosting queues summary'),
    'cache' => DRUPAL_NO_CACHE, // DRUPAL_CACHE_PER_ROLE is the default
    'enabled' => 1,
    'region' => 'right',
    'weight' => 1,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function hosting_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'hosting_queues':
      $block['subject'] = t('Queues');
      $block['content'] = hosting_queue_block();
      break;

    case 'hosting_queues_summary':
      $block['subject'] = t('Queues summary');
      $block['content'] = hosting_queue_summary_block();
      break;

  }

  return $block;
}

/**
 * Build a block summarising the hosting queues.
 *
 * @todo Change this to return a render array.
 */
function hosting_queue_summary_block() {
  if (user_access('administer hosting queues')) {
    $queues = hosting_get_queues();
    $output = '';
    foreach ($queues as $queue => $info) {
      $disp = array();
      # special case
      if (!$info['enabled']) {
        $disp[] = t('Status: disabled');
        continue;
      }
      $disp[] = t('Status: enabled');
      foreach (array('description' => t('Description'), 'frequency' => t('Frequency'), 'items' => t('Items per run'), 'total_items' => t('Items in queue'), 'last_run' => t('Last run')) as $key => $title) {
        if ($key == 'last_run') {
          $info[$key] = hosting_format_interval($info[$key]);
        } elseif ($key == 'frequency') {
          $info[$key] = t('every @interval', array('@interval' => format_interval($info[$key])));
        }
        $disp[] = $title . ": " . $info[$key];
      }
      $output .= theme('item_list', $disp, $info['name']);
    }
    return $output;
  }
}

/**
 * Build a block of the hosting queues.
 *
 * @see hosting_TASK_SINGULAR_summary()
 * @todo Change this to return a render array.
 */
function hosting_queue_block() {
  if (user_access('access task logs')) {
    $queues = hosting_get_queues();
    $output = '';
    foreach ($queues as $queue => $info) {
      $func = 'hosting_'.$info['singular'].'_summary';
      if (function_exists($func)) {
        $output .= $func();
      }
    }
    return $output;
  }
}

/**
 * Check site URL is allowed.
 *
 * This function hooks into hook_allow_domain to let contrib modules
 * weigh in on whether the site should be created.
 *
 * All the hooks must return true for the domain to be allowed.
 *
 * @see hook_allow_domain()
 */
function hosting_domain_allowed($url, $params = array()) {
  $results = module_invoke_all('allow_domain', $url, $params);
  $return = !in_array(FALSE, $results);
  return $return;
}

/**
 * Replacement node/add page.
 *
 * Major kludge to remove the hidden node types from node/add page.
 *
 * Copied from node.module.
 */
function _hosting_node_add($type = '') {
  global $user;

  $types = node_get_types();
  $type = ($type) ? str_replace('-', '_', $type) : NULL;

  if ($type == 'package') {
    drupal_access_denied();
  }
  // If a node type has been specified, validate its existence.
  if (isset($types[$type]) && user_access('create ' .  $type) && (hosting_feature($type) !== HOSTING_FEATURE_DISABLED)) {
    // Initialize settings:
    $node = array('uid' => $user->uid, 'name' => $user->name, 'type' => $type);

    drupal_set_title(t('Submit @name', array('@name' => $types[$type]->name)));
    $output = drupal_get_form($type .'_node_form', $node);
  }
  else {
    // If no (valid) node type has been provided, display a node type overview.
    foreach ($types as $type) {
      if (function_exists($type->module .'_form') && user_access('create ' . $type->type) && (hosting_feature($type->type) !== HOSTING_FEATURE_DISABLED)) {
        $type_url_str = str_replace('_', '-', $type->type);
        $title = t('Add a new @s.', array('@s' => $type->name));
        $out = '<dt>'. l(drupal_ucfirst($type->name), "node/add/$type_url_str", array('attributes' => array('title' => $title))) .'</dt>';
        $out .= '<dd>'. filter_xss_admin($type->description) .'</dd>';
        $item[$type->name] = $out;
      }
    }

    if (isset($item)) {
      uksort($item, 'strnatcasecmp');
      $output = t('Choose the appropriate item from the list:') .'<dl>'. implode('', $item) .'</dl>';
    }
    else {
      $output = t('No content types available.');
    }
  }

  return $output;
}

/**
 * List queues or tasks in a queue if a key is provided.
 *
 * @see hosting_TASK_SINGULAR_list()
 */
function hosting_queues($key = '') {
  $queues = hosting_get_queues();

  if ($queues[$key]) {
    if ($queues[$key]['name']) {
      $output .= "<h1>".$queues[$key]['name']."</h1>";
    }

    $func = 'hosting_'.$queues[$key]['singular'].'_list';
    if (function_exists($func)) {
      $output .= $func();
    }
  }
  else {
    foreach($queues as $key => $queue) {
      $item[] = l($queue['name'], 'hosting/queues/'.$key);
    }
    $output .= theme('item_list', $item, t('Queues'));
  }

  return $output;
}

/**
 * Generate context sensitive breadcrumbs.
 *
 * @param $node
 *   A node object to use for context of the breadcrumbs.
 * @todo This has no business being here, factor out to provider modules.
 */
function hosting_set_breadcrumb($node) {
  $breadcrumbs[] = l(t('Home'), NULL);
  switch ($node->type) {
    case 'task':
      $breadcrumbs[] = _hosting_node_link($node->rid);
      break;
    case 'platform' :
      $breadcrumbs[] = _hosting_node_link($node->web_server);
      break;
    case 'site' :
      $breadcrumbs[] = _hosting_node_link($node->platform);
      break;
    case 'server' :
      $breadcrumbs[] = l(t('Servers'), 'hosting/servers');
      break;
  }
  drupal_set_breadcrumb($breadcrumbs);
}

/**
 * Implementation of hook_form_alter().
 */
function hosting_form_alter(&$form, &$form_state, $form_id) {
  // Alter the 'Add User' form to remind users that this is not the New Client form
  if ($form_id == 'user_register') {
    $form[user_registration_help] = array(
      '#type' => 'item',
      '#description' => t('<strong>Adding a system user account does not make the user a Client that can add sites.</strong><br />
                     To add a Client, enable the Client feature and then add a new Client node.<br />
                     If you wish, you may then assign this system user to the Client as an \'Allowed user\' to inherit the permissions to add sites.'),
      '#weight' => '-10'
    );
  }

  if ($form_id == 'package_node_form') {
    drupal_access_denied();
  }


  // Remove additional UI added by core modules, that conflict with the hosting UI.
  $node_types = array('site', 'platform', 'server', 'client');
  foreach ($node_types as $type) {
    if ($form_id == $type . '_node_form') {
      unset($form['options']);
      unset($form['menu']);
      unset($form['revision_information']);
      unset($form['author']);
      unset($form['comment_settings']);

      // because these aren't really posts, 'preview' doesnt make sense in this context.
      unset($form['buttons']['preview']);
    }
  }
}

/**
 * Hosting version of menu_rebuild() from Drupal 6.15
 * This is needed for the upgrade path of a hostmaster platform from
 * 6.15 to 6.16. The Hosting module calls update hooks that run
 * menu_rebuild() which break on a 6.16 platform as the semaphore
 * table has not yet been introduced by system_update_6054()
 * It is considered safe enough to ignore the new locking checks in
 * 6.16's menu_rebuild() to get us past this step to successfully
 * complete the hostmaster-migrate task.
 */
function hosting_menu_rebuild() {
  variable_del('menu_rebuild_needed');
  $menu = menu_router_build(TRUE);
  _menu_navigation_links_rebuild($menu);
  // Clear the menu, page and block caches.
  menu_cache_clear_all();
  _menu_clear_page_cache();
  if (defined('MAINTENANCE_MODE')) {
    variable_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Get the node associated with a given provision context.
 *
 * @param $name
 *   The name of the context to load.
 * @return
 *   Either the node object associated with the context, or FALSE if no
 *   associated node can be found.
 */
function hosting_context_load($name) {
  $name = ltrim($name, '@');
  // TODO : introduce static caching ?

  $nid = db_query("SELECT nid FROM {hosting_context} WHERE name = :name", array(':name' => $name))->fetchField();

  if (!empty($nid)) {
    return node_load($nid);
  }
  return FALSE;
}

/**
 * Add a node to the context lookup db.
 *
 * @param $nid
 *   The nid of the node to associate to the given provision context name.
 * @param $name
 *   The name of the provision context.
 */
function hosting_context_register($nid, $name) {
  // Insert, or update the record in the DB.
  db_merge('hosting_context')
    ->key(array('nid' => $nid))
    ->fields(array(
        'name' => $name,
    ))
    ->execute();
  // We include the file instead of enabling the module,
  // because we do not want the overhead of having all the
  // path UI stuff on nodes.
  require_once("./modules/path/path.module");
  path_set_alias("node/$nid", "hosting/c/$name");
}

/**
 * Delete an alias from the context lookup table.
 *
 * @param $nid
 *   The nid of the node to remove the association from.
 */
function hosting_context_delete($nid) {
  db_delete('hosting_context')
    ->condition('nid', $nid)
    ->execute();
}

/**
 * Return the hosting context name for a node.
 *
 * @param $nid
 *   The nid of the node to get the provision context name for.
 * @return
 *   The provision context name associated with the specified node, will be
 *   prefixed with '@'.
 */
function hosting_context_name($nid) {
  $node = node_load($nid);
  return '@' . $node->hosting_name;
}

/**
 * Define the node types that have associated provision contexts.
 */
function hosting_context_node_types() {
  return array('site', 'platform', 'server');
}

/**
 * Implementation of hook_views_api().
 */
function hosting_views_api() {
  return array(
    'api' => 2,
  );
}
