<?php
/**
 * @file
 *   Allow clients to be created and granted permissions over sites, tasks etc.
 */

include drupal_get_path( 'module', 'node' ) . '/node.pages.inc';
include dirname(__FILE__) . '/hosting_client.access.inc';
/**
 * The maximum length of a UNIX group
 *
 * Used to determine the sane maximum length of the internal name of a
 * client.
 *
 * @see hosting_client_sanitize()
 * @see http://community.aegirproject.org/node/557
 */
define('MAX_GROUP_LENGTH', 16);

/**
 * Implements hook_node_info().
 */
function hosting_client_node_info() {
  $types["client"] =  array(
    "name" => t('Client'),
    'base' => 'hosting_client',
    "has_title" => TRUE,
    "title_label" => 'Client name',
    "description" => hosting_node_help("client"),
    "has_body" => 0,
    "body_label" => '',
    "min_word_count" => 0,
  );

  return $types;
}

/**
 * Implements hook_theme().
 */
function hosting_client_theme($existing, $type, $theme, $path) {
  return array(
    'hosting_client_user_form' => array(
      'file' => 'hosting_client.access.inc',
      'render element' => 'form',
    ),
    'hosting_client_form' => array(
      'file' => 'hosting_client.module',
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function hosting_client_permission() {
  return array(
    'create client' => array(
      'title' => t('create client'),
      'description' => t('TODO Add a description for \'create client\''),
    ),
    'view client' => array(
      'title' => t('view client'),
      'description' => t('TODO Add a description for \'view client\''),
    ),
    'edit own client' => array(
      'title' => t('edit own client'),
      'description' => t('TODO Add a description for \'edit own client\''),
    ),
    'delete own client' => array(
      'title' => t('delete own client'),
      'description' => t('TODO Add a description for \'delete own client\''),
    ),
    'administer clients' => array(
      'title' => t('administer clients'),
      'description' => t('TODO Add a description for \'administer clients\''),
    ),
    'edit client users' => array(
      'title' => t('edit client users'),
      'description' => t('TODO Add a description for \'edit client users\''),
    ),
    'edit client uname' => array(
      'title' => t('edit client uname'),
      'description' => t('TODO Add a description for \'edit client uname\''),
    ),
  );
}

/**
 * Implements hook_node_access().
 */
function hosting_client_node_access($node, $op, $account) {
  if (!hosting_feature('client')) {
    // multiple client support has been disabled for this site.
    return FALSE;
  }

  if (user_access('administer clients', $account)) {
    return TRUE;
  }
  else {

    switch ($op) {
      case 'create':
        return user_access('create client', $account);
        break;
      case 'view':
        return user_access('view client', $account) && db_query("SELECT user FROM {hosting_client_user} WHERE user = :user and client = :client", array(':user' => $account->uid, ':client' => $node->nid))->fetchAssoc();
      case 'update':
        if (user_access('edit own client', $account) && $account->uid == $node->uid) {
          return TRUE;
        }
        break;
      case 'delete':
        if ((user_access('delete own client', $account) && $account->uid == $node->uid)) {
          return TRUE;
        }
        break;
      default:
        break;
    }
  }
}

/**
 * Get a client by name or nid.
 *
 * @param $client
 *   Either the nid or the client title
 */
function hosting_get_client($client) {
  if (is_numeric($client)) {
    // TODO: confirm that we validate against numeric client names.
    return node_load($client);
  }
  else {
    if ($nodes = node_load_multiple(array(), array('type' => 'client', 'title' => $client))) {
      return $nodes[0];
    }
    else {
      return FALSE;
    }
  }
}

/**
 * Get a client by internal name.
 *
 * @see hosting_get_client()
 * @param $uname
 *   The internal name of this client.
 */
function hosting_get_client_by_uname($uname) {
  $result = db_query("SELECT c.nid FROM {hosting_client} c JOIN {node} n ON c.nid = n.nid WHERE c.uname = !c.uname AND n.type = !n.type", array('!c.uname' => $uname, '!n.type' => 'client'))->fetchField();
  if ($result) {
    return node_load($result);
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_form().
 */
function hosting_client_form(&$node, &$form_state) {
  $type = node_type_get_type('client');

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#required' => TRUE,
    '#size' => 40,
    '#default_value' => $node->title,
    '#maxlength' => 100,
    '#description' => t('The name of this client, generally the organization name or the contact name for individuals.'),
  );

  $form['uname'] = array(
    '#type' => 'textfield',
    '#title' => t('Internal name'),
    '#size' => MAX_GROUP_LENGTH,
    '#maxlength' => MAX_GROUP_LENGTH,
    '#default_value' => isset($node->uname) ? $node->uname : '',
    '#access' => user_access('edit client uname'),
    '#description' => t('A machine-usable name that can be used internally, for example to map to a UNIX group in the backend. It is unique accross the system. If no value is provided, it is deduced from the client name, by stripping spaces and metacharacters and adding a prefix (%prefix).', array('%prefix' => variable_get('hosting_client_prefix', 'no prefix define'))),
  );
  if (!isset($node->nid) && variable_get('hosting_client_register_user', FALSE)) {
    $form['email'] = array(
      '#type' => 'textfield',
      '#title' => t('Email address'),
      '#description' => t('Email address of the contact created with this client. Optional - if none is provided, no user will be created with this client.'),
      '#required' => FALSE,
      '#size' => 40,
      '#default_value' => $node->email,
      '#maxlength' => 100,
    );

    $form['email_confirm'] = array(
      '#type' => 'textfield',
      '#title' => t('Confirm Email address'),
      '#required' => FALSE,
      '#size' => 40,
      '#maxlength' => 100,
    );
  }

  if (isset($node->nid)) {
    $users = hosting_client_users($node);
    $user_list = array();
    foreach ($users as $uid => $uname) {
      $form['user_edit']['name'][$uid] = array(
        '#type' => 'markup',
        '#value' => l($uname, 'user/' . $uid),
      );
      $user_list[$uid] = '';
    }
    if (user_access('edit client users')) {
      $form['user_edit']['users'] = array(
        '#type' => 'checkboxes',
        '#options' => $user_list,
      );
    }
    $form['user_edit']['header'] = array(
      '#type' => 'value',
      '#value' => array(array('data' => t('Allowed users')), array('data' => t('Remove'))),
    );
    if (user_access('edit client users')) {
      $form['user_edit']['new_user'] = array(
        '#type' => 'textfield',
        '#title' => t('Associate a user to this Client'),
        '#weight' => 2,
        '#autocomplete_path' => 'user/autocomplete',
        '#description' => t('This field allows you to associate an existing system user to this Client.
                             It does not create a new system user, but allows an existing user
                             to manage sites belonging to the Client.'),
      );
    }
    $form['user_edit']['#theme'] = 'hosting_client_form';
  }
  else {
    global $user;
    $form['new_user'] = array(
      '#type' => 'value',
      '#value' => $user->name,
    );
  }
  return $form;
  // @ignore security_fapi_markup
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_hosting_client_form($variables) {
  $form = $variables['form'];
  foreach (element_children($form['name'], FALSE) as $user) {
    $row = array();
    // TODO: Figure out why drupal_render isn't working here.
    //$row['data'][] = drupal_render($form['name'][$user]);
    $row['data'][] = $form['name'][$user]['#value'];
    if (user_access('edit client users')) {
      $row['data'][] = drupal_render($form['users'][$user]);
    }
    $rows[] = $row;
  }
  $output = theme('table', array('header' => $form['header']['#value'], 'rows' => $rows));
  $output .= drupal_render_children($form);
  return $output;
}

/**
 * Implements hook_validate().
 */
function hosting_client_validate($node, $form, &$form_state) {
  if ($node->uname) {
    $node->uname = hosting_client_sanitize($node->uname);
  }
  else {
    $node->uname = hosting_client_sanitize($node->title);
  }
  // TODO convert this statement to DBTNG syntax.
  $nid = db_query("SELECT nid FROM {hosting_client} WHERE uname LIKE '!existing'", array('!existing' => addcslashes($node->uname, '\%_')))->fetchField();
  if ($nid && $node->nid != $nid) {
    $suggestion = hosting_client_validate_suggest($node);
    if ($suggestion) {
      form_set_error('title', t("Client name already in use, try %suggestion.", array('%suggestion' => $suggestion)));
    }
    else {
      form_set_error('title', t("Client name already in use."));
    }
  }
  if (!$node->nid && isset($node->email)) {
    $user = array_shift(user_load_multiple(array(), array('mail' => $node->email)));
    if ($user) {
      form_set_error('email', t("Email address already exists."));
    }
    if ($node->email != $node->email_confirm) {
      form_set_error('email_confirm', t("Email addresses do not match"));
    }
    if (!valid_email_address($node->email)) {
      form_set_error('email', t("Email address invalid."));
    }
  }
}

/**
 * Helper for hosting_client_validate to suggest a new client title.
 *
 * @see hosting_client_validate()
 * @param $node
 *   The node being validated
 */
function hosting_client_validate_suggest($node) {
  $suggestion = FALSE;
  for ($i = 0; $i < 10; $i++) {
    // TODO convert this statement to DBTNG syntax.
    $nid = db_query("SELECT nid FROM {hosting_client} WHERE uname LIKE '%s%%'", addcslashes(hosting_client_sanitize($node->title) . $i, '\%_'))->fetchField();
    if (!$nid) {
      $suggestion = $node->title . $i;
      break;
    }
  }
  return $suggestion;
}

/**
 * Implements hook_insert().
 */
function hosting_client_insert($node) {
  if (isset($node->uname)) {
    $node->uname = hosting_client_sanitize($node->uname);
  }
  else {
    $node->uname = hosting_client_sanitize($node->title);
  }
  $id = db_insert('hosting_client')
    ->fields(array(
      'vid' => $node->vid,
      'nid' => $node->nid,
      'uname' => $node->uname,
    ))
    ->execute();
  if (variable_get('hosting_client_register_user', FALSE)
     && !array_shift(user_load_multiple(array(), array('mail' => $node->email)))) {
    $user = hosting_client_register_user($node);
    $node->uid = $user->uid;
    db_update('node')
      ->fields(array(
        'uid' => $user->uid,
      ))
      ->condition('nid', $node->nid)
      ->execute();
    db_update('node_revisions')
      ->fields(array(
        'uid' => $user->uid,
      ))
      ->condition('vid', $node->vid)
      ->execute();
  }
  if (isset($node->new_user)) {
    $user = array_shift(user_load_multiple(array(), array('name' => $node->new_user)));
    if ($user) {
      $id = db_insert('hosting_client_user')
        ->fields(array(
          'client' => $node->nid,
          'user' => $user->uid,
          'contact_type' => '',
        ))
        ->execute();
    }
  }
}

/**
 * Shortcut to get the rid of the 'aegir client' role.
 *
 * This hardcodes the 'aegir client' role name, so if it is changed,
 * this will fail.
 *
 * @todo the rid or role name should be a variable
 * @deprecated remove this function once the above setting is implemented
 */
function _hosting_client_get_role() {
  return db_query("SELECT rid FROM {role} WHERE name = :name", array(':name' => 'aegir client'))->fetchField();
}

/**
 * Register a new user account for the client.
 *
 * This is a helper function for client forms that will create a user
 * alongside a new client if the hosting_client_register_user setting
 * is true.
 *
 * @see hosting_client_insert()
 */
function hosting_client_register_user($node) {
  $pass = user_password();
  $user = new stdClass();
  $edit['name'] = $node->uname;
  $edit['hosting_client'] = $node->nid;
  $edit['mail'] = $node->email;
  $edit['pass'] = $pass;
  $edit['status'] = 1;
  $edit['roles'][_hosting_client_get_role()] = TRUE;
  $user = user_save($user, $edit);

  if ($user->uid && variable_get('hosting_client_send_welcome', FALSE)) {
    if ($node->client_name) {
      $to = sprintf("%s <%s>", $node->client_name, $node->email);
    }
    else {
      $to = $node->email;
    }

    $params = array(
      '!username' => $user->name,
      '!site' => variable_get('site_name', 'Drupal'),
      '!password' => $pass,
      '!uri' => $GLOBALS['base_url'],
      '!uri_brief' => substr($base_url, strlen('http://')),
      '!date' => format_date(REQUEST_TIME),
      '!login_uri' => url('user', array('absolute' => TRUE)),
      '!edit_uri' => url('user/' . $user->uid . '/edit', array('absolute' => TRUE)),
      '!login_url' => user_pass_reset_url($user),
    );
    // No e-mail verification is required, create new user account, and login user immediately.
    $language = user_preferred_language($user);
    drupal_mail('hosting_client', 'hosting-client-register-welcome', $to, $language, $params);
  }
  return $user;
}

/**
 * Implements hook_mail().
 */
function hosting_client_mail($key, &$message, $params) {
  switch ($key) {
    case 'hosting-client-register-welcome':
      $message['subject'] = _hosting_client_mail_text('welcome_subject', $params);
      $message['body'] = _hosting_client_mail_text('welcome_body', $params);
      break;
  }
}


/**
 * Implements hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function hosting_client_update($node) {
  // if this is a new node or we're adding a new revision,
  if ($node->revision) {
    hosting_client_insert($node);
  }
  else {
    if ($node->uname) {
      $node->uname = hosting_client_sanitize($node->uname);
    }
    else {
      $node->uname = hosting_client_sanitize($node->title);
    }
    db_update('hosting_client')
      ->fields(array(
        'uname' => $node->uname,
      ))
      ->condition('nid', $node->nid)
      ->execute();
  }
  if ($node->users) {
    foreach ($node->users as $user) {
      db_delete('hosting_client_user')
        ->condition('user', $user)
        ->condition('client', $node->nid)
        ->execute();
    }
  }
  if ($node->new_user) {
    $user = array_shift(user_load_multiple(array(), array('name' => $node->new_user)));
    $id = db_insert('hosting_client_user')
      ->fields(array(
        'client' => $node->nid,
        'user' => $user->uid,
        'contact_type' => '',
      ))
      ->execute();
  }
}

/**
 * Implementation of hook_nodeapi_TYPE_OP().
 *
 * @see hosting_nodeapi()
 */
function hosting_nodeapi_client_delete_revision(&$node) {
  db_delete('hosting_client')
    ->condition('vid', $node->vid)
    ->execute();
}

/**
 * Implements hook_delete().
 */
function hosting_client_delete($node) {
  db_delete('hosting_client')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_load().
 *
 * @param $node
 *    Node object
 */
function hosting_client_load($nodes) {
  foreach ($nodes as $nid => &$node) {
    $additions = db_query('SELECT uname FROM {hosting_client} WHERE vid = :vid', array(':vid' => $node->vid))->fetch();
    foreach ($additions as $property => &$value) {
      $node->$property = $value;
    }
  }
}

/**
 * Implements hook_node_load().
 *
 * @param $arg
 *    Node's numeric nid
 */
function hosting_client_node_load($arg) {
  if (!is_numeric($arg)) {
    return FALSE;
  }
  if ($node = node_load_multiple(array($arg))) {
    if ($node->type == 'client') {
      return $node;
    }
  }
  return FALSE;
}

/**
 * Return a list of users for a given client.
 *
 * @param $node
 *   Client node (as nid or node object).
 * @return
 *   Array of user names indexed by uid.
 *
 */
function hosting_client_users($node) {
  if (is_object($node)) {
    $node = $node->nid;
  }
  elseif (!is_numeric($node)) {
    return array();
  }
  // TODO: Figure out why variable substitution doesn't work here.
  return db_query("SELECT u.uid, u.name, h.client FROM {hosting_client_user} h INNER JOIN {users} u ON u.uid = h.user WHERE h.client = $node")->fetchAllKeyed();
}

/**
 * Implements hook_view().
 */
function hosting_client_view($node, $teaser = FALSE, $page = FALSE) {
  $type = node_type_get_type($node);

  $node->content['info']['#prefix'] = '<div id="hosting-client-info">';
  $node->content['info']['title'] = array(
    '#type' => 'item',
    '#title' => $type->title_label,
    '#value' => filter_xss($node->title),
  );
  $node->content['info']['uname'] = array(
    '#type' => 'item',
    '#title' => t('Internal name'),
    '#weight' => 1,
    '#value' => filter_xss($node->uname),
  );

  $node->content['info']['#suffix'] = '</div>';
  if ($page) {
    $node->content['sites_view'] = array(
      '#type' => 'item',
      '#value' => drupal_get_form('hosting_site_list_form', 'client', $node->nid),
      '#prefix' => '<div id="hosting-site-list">',
      '#suffix' => '</div>',
      '#weight' => 10,
    );

    $users = hosting_client_users($node);
    foreach ($users as $uid => $uname) {
      if (user_access('access user profiles') || ($uid == $GLOBALS['user']->uid)) {
        $rows[] = array(l($uname, 'user/' . $uid));
      }
      else {
        $rows[] = array($uname);
      }
    }

    $header = array(t('Allowed users'));
    $node->content['users_view'] = array(
      '#type' => 'item',
      '#value' => theme('table', array('header' => $header, 'rows' => $rows)),
      '#class' => 'client',
      '#prefix' => '<div id="hosting-site-list">',
      '#suffix' => '</div>',
      '#weight' => 11,
    );
  }
  return $node;
}

/**
 * Implements hook_hosting_site_site_list_filters().
 */
function hosting_client_hosting_site_site_list_filters() {
  return array('client');
}

/**
 * Helper function to generate new client node during import.
 *
 * @param $name
 *   Client name.
 * @return
 *   The nid of the generated client.
 */
function hosting_import_client($name) {
  $client = hosting_get_client_by_uname($name);

  if (!$client) {
    $client = new stdClass();
    $client->type = 'client';
    $client->uid = 1;
    $client->title = trim($name);
    $client->status = 1;
    node_save($client);
  }

  return $client;
}

/**
 * Implements hook_menu().
 */
function hosting_client_menu() {
  $items['node/%node/site/add'] = array(
    'title' => 'Add site',
    'description' => 'Add a site to the current client',
    'page callback' => 'hosting_client_site_form',
    'page arguments' => array('site_node_form', 1),
    'access callback' => 'hosting_client_menu_access',
    'access arguments' => array('create site', 1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['hosting_client/autocomplete'] = array(
    'title' => 'hosting client get client autocomplete',
    'page callback' => 'hosting_client_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/hosting/client'] = array(
    'title' => 'Clients',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hosting_client_configure'),
    'access callback' => '_hosting_client_configure_access',
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}


/**
 * Get the default value of the client field for a site node.
 *
 * @param $node
 *   The site to the the clients for.
 */
function _hosting_client_site_default($node) {
  # find the right client
  global $user;
  $current_client_id = 0;

  if ($user->uid) {
    $client_ids = hosting_get_client_from_user($user->uid);
    $clients = array();
    foreach ($client_ids as $client_id => $client_permissions) {
      $client_id = $client_id ? $client_id : HOSTING_DEFAULT_CLIENT;
      $client = node_load_multiple(array($client_id));
      $client = $client[$client_id];
      $clients[$client->title] = $client->title;
      if (isset($node->client) && ($node->client == $client_id || !$current_client_id)) {
        $current_client_id = $client_id;
      }
    }
    if (!$current_client_id && !user_access('administer clients')) {
      form_set_error('client', t('Your user is not associated with any clients so you are not allowed to create new sites'));
    }
  }

  if (!$current_client_id) {
    $current_client_id = HOSTING_DEFAULT_CLIENT;
  }

  // allow admins to override
  if (isset($node->client) && $node->client && user_access('administer clients')) {
    $current_client_id = $node->client;
  }

  $client = node_load_multiple(array($current_client_id));
  if (!$client) {
    # we give up, couldn't find a client, we're probably in a preview so
    # just use the node client
    $client = new stdClass();
    $client->title = isset($node->client) ? $node->client : NULL;
  }

  return $client->title;
}

/**
 * Wrapper around the regular site_node_form that passes a dummy site with a proper client
 */
function hosting_client_site_form($form, $node) {
  $site = new stdClass();
  $site->type = 'site';
  $site->client = $node->nid;
  return drupal_get_form('site_node_form', $site);
}

/**
 * Menu access callback for the site creation tab in the client node.
 *
 * @see hosting_client_menu()
 */
function hosting_client_menu_access($perm, $node) {
  if ($node->type == 'client') {
    return user_access($perm);
  }
  else {
    return FALSE;
  }
}

/**
 * Menu access callback for the client settings.
 *
 * @see hosting_client_menu()
 */
function _hosting_client_configure_access() {
  return user_access('administer clients') && hosting_feature('client');
}

/**
 * Expand the client registration email message based on the variables
 *
 * This will check for a custom message set in the
 * hosting_client_mail_welcome_subject and
 * hosting_client_mail_welcome_body variables.
 */
function _hosting_client_mail_text($messageid, $variables = array()) {
  // Check if an admin setting overrides the default string.
  if ($admin_setting = variable_get('hosting_client_mail_' . $messageid, FALSE)) {
    return strtr($admin_setting, $variables);
  }

  switch ($messageid) {
    case 'welcome_subject':
      return t('Account details for !username at !site', $variables);
    case 'welcome_body':
      return t("!username,\n\nThank you for registering at !site. You may now log in to !login_uri using the following username and password:\n\nusername: !username\npassword: !password\n\nYou may also log in by clicking on this link or copying and pasting it in your browser:\n\n!login_url\n\nThis is a one-time login, so it can be used only once.\n\nAfter logging in, you will be redirected to !edit_uri so you can change your password.\n\n\n--  !site team", $variables);

  }
}

/**
 * Menu callback for the module's settings.
 *
 * @see hosting_client_menu()
 */
function hosting_client_configure($form, &$form_state) {
  $form['hosting_client_prefix'] = array(
    '#type' => 'textfield',
    '#title' => t('Client internal name prefix'),
    '#description' => t('Client nodes have an internal name that can be mapped to a UNIX group. This is the prefix assigned to that internal name to make sure it is in a separate namespace. Note that UNIX groups are generally limited to 16 characters so this prefix should be kept short. It can also be empty, in which case no prefix will be added.'),
    '#default_value' => variable_get('hosting_client_prefix', ''),
    '#size' => 5,
    '#maxlength' => 16,
  );
  $form['hosting_client_register_user'] = array(
    '#type' => 'checkbox',
    '#title' => t('Automatically create user accounts for new clients.'),
    '#description' => t('If this setting is on, any new client nodes will automatically have a system user account generated for them, and associated with the new client node. Users going through the signup form module have a user created regardless of this setting.'),
    '#default_value' => variable_get('hosting_client_register_user', FALSE),
  );

  // User e-mail settings.
  $form['email'] = array(
    '#type' => 'fieldset',
    '#title' => t('User e-mail settings'),
  );
  $form['email']['hosting_client_send_welcome'] = array(
    '#type' => 'checkbox',
    '#title' => t('Send welcome mail to new clients.'),
    '#description' => t('If this setting is on, new clients will receive a welcome email containing their login details.'),
    '#default_value' => variable_get('hosting_client_send_welcome', FALSE),
  );
  $form['email']['hosting_client_mail_welcome_subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Subject of welcome e-mail'),
    '#default_value' => _hosting_client_mail_text('welcome_subject'),
    '#maxlength' => 180,
    '#description' => t('Customize the subject of your welcome e-mail, which is sent to new members upon registering.')
    . ' ' . t('Available variables are:') . ' !username, !site, !password, !uri, !uri_brief, !date, !login_uri, !edit_uri, !login_url.',
  );
  $form['email']['hosting_client_mail_welcome_body'] = array(
    '#type' => 'textarea',
    '#title' => t('Body of welcome e-mail'),
    '#default_value' => _hosting_client_mail_text('welcome_body'),
    '#rows' => 15,
    '#description' => t('Customize the body of the welcome e-mail, which is sent to new members upon registering.')
    . ' ' . t('Available variables are:') . ' !username, !site, !password, !uri, !uri_brief, !login_uri, !edit_uri, !login_url.',
  );


  return system_settings_form($form);

}

/**
 * Get 25 clients in a paged query.
 */
function _hosting_get_clients() {
  $return = array();
  // TODO: Confirm that these are equivalent.
  //$result = pager_query(db_rewrite_sql('SELECT n.nid, n.title from {node} n WHERE n.type = "client"'), 25);
  $query = db_select('node', 'n')->extend('PagerDefault');
  $result = $query
    ->fields('n', array('nid', 'title'))
    ->condition('type', 'client')
    ->limit(25)
    ->addTag('node_access')
    ->execute();
  foreach ($result as $client) {
    $return[$client->nid] = $client->title;
  }
  return $return;
}

/**
 * Make a themed list of clients.
 *
 * Will take whatever _hosting_get_clients() will give as clients.
 *
 * @see _hosting_get_clients()
 */
function hosting_client_list() {
  $summary = array();
  $clients = _hosting_get_clients();
  return theme('item_list', array('items' => array_map('_hosting_node_link', array_keys($clients))));
}

/**
 * Implements hook_block_info().
 */
function hosting_client_block_info() {
  $blocks['hosting_clients'] = array(
    'info' => t('Hosting clients'),
    'enabled' => 1,
    'region' => 'left',
    'weight' => 10,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function hosting_client_block_view($delta) {
  switch ($delta) {
    case 'hosting_clients':
      $blocks['title'] = t('Clients');
      $blocks['content'] = user_access('view client') ? hosting_client_list() : '';
      break;

  }
}

/**
 * Implements hook_block().
 */
function hosting_client_block_OLD($op = 'list', $delta = 0, $edit = array()) {
  // TODO Remaining code in this function needs to be moved to the appropriate new hook function.
  $blocks = array();
  return $blocks;
}

/**
 * Retrieve autocomplete suggestions.
 */
function hosting_client_autocomplete($type, $keyword) {
  $matches = array();

  if ($type == 'client') {
    // TODO Confirm that these are equivalent, especially the db_rewrite_sql -> addTag('node_access')
    // $query = db_query(db_rewrite_sql("SELECT * FROM {node} n WHERE type = '%s' AND title LIKE '%s%%'"), $type, addcslashes($keyword, '\%_'));
    $query = db_select('node', 'n')
      ->condition('type', $type);
    $query->addField('n', 'title');
    $query = $query
      ->condition('title', '%' . $keyword . '%' , 'LIKE')
      ->addTag('node_access');
      $result = $query->execute();
    foreach ($result as $client) {
      $matches[$client->title] = $client->title;
    }
  }

  drupal_json_output($matches);
  exit();
}

/**
 * Implements hook_form_alter().
 */
function hosting_client_form_alter(&$form, &$form_state, $form_id) {
  if (user_access('administer clients')) {
    if (hosting_feature('client') && $form_id == 'platform_node_form') {
      global $user;
      $node = $form["#node"];
      // Show a list of clients to give access to this platform
      $clients = _hosting_get_clients();
      $form['clients'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Platform access control'),
        '#options' => $clients,
        '#default_value' => isset($node->clients) ? $node->clients : array(),
        '#description' => t('Grant access to this platform for relevant clients where required. Leave all checkboxes unchecked to grant all clients access to this platform.'),
      );
    }
  }
}

/**
 * Implementation of hook_nodeapi_TYPE_OP().
 *
 * This loads the platform/client access control mappings in the platform node.
 *
 * @todo move this to the platform module (!!)
 * @see hosting_nodeapi()
 */
function hosting_nodeapi_platform_load($node) {
  $result = db_query("SELECT cid FROM {hosting_platform_client_access} WHERE pid = :pid", array(':pid' => $node->nid));

  $additions = array();

  while ($record = $result->fetch()) {
    $additions['clients'][$record->cid] = $record->cid;
  }

  return $additions;
}

/**
 * Implements hook_node_insert().
 */
function hosting_client_node_insert($node) {
  if ($node->type == 'platform') {
    // Enter access rights in to the db for clients if any were selected
    if (!empty($node->clients)) {
      $clients = $node->clients;
      foreach ($clients as $cid => $choice) {
        if ($choice) {
          // Client has been selected, add them to the access table
          $existing = db_query("SELECT cid FROM {hosting_platform_client_access} WHERE pid = :pid AND cid = :cid", array(':pid' => $node->nid, ':cid' => $cid))->fetchField();
          if (!$existing) {
            $id = db_insert('hosting_platform_client_access')
              ->fields(array(
                'pid' => $node->nid,
                'cid' => $cid,
              ))
              ->execute();
          }
        }
        else {
          // Client has not been selected, or unselected
          $existing = db_query("SELECT cid FROM {hosting_platform_client_access} WHERE pid = :pid AND cid = :cid", array(':pid' => $node->nid, ':cid' => $cid))->fetchField();
          if ($existing) {
            db_delete('hosting_platform_client_access')
              ->condition('pid', $node->nid)
              ->condition('cid', $cid)
              ->execute();
          }
        }
      }
    }
  }
}

/**
 * Implements hook_node_update().
 */
function hosting_client_node_update($node) {
  if ($node->type == 'platform') {
    // Enter access rights in to the db for clients if any were selected
    if (!empty($node->clients)) {
      $clients = $node->clients;
      foreach ($clients as $cid => $choice) {
        if ($choice) {
          // Client has been selected, add them to the access table
          $existing = db_query("SELECT cid FROM {hosting_platform_client_access} WHERE pid = :pid AND cid = :cid", array(':pid' => $node->nid, ':cid' => $cid))->fetchField();
          if (!$existing) {
            $id = db_insert('hosting_platform_client_access')
              ->fields(array(
                'pid' => $node->nid,
                'cid' => $cid,
              ))
              ->execute();
          }
        }
        else {
          // Client has not been selected, or unselected
          $existing = db_query("SELECT cid FROM {hosting_platform_client_access} WHERE pid = :pid AND cid = :cid", array(':pid' => $node->nid, ':cid' => $cid))->fetchField();
          if ($existing) {
            db_delete('hosting_platform_client_access')
              ->condition('pid', $node->nid)
              ->condition('cid', $cid)
              ->execute();
          }
        }
      }
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function hosting_client_node_delete($node) {
  if ($node->type == 'platform') {
    db_delete('hosting_platform_client_access')
      ->condition('pid', $node->nid)
      ->execute();
  }
}

/**
 * Small helper function to get platforms that haven't been deleted or locked,
 * and are accessible by this user.
 *
 * We can get called a few times during a page request, so we implement static
 * caching for speed, and because the platforms that are available are unlikely
 * to change during a single page request.
 *
 * @param $uid
 *   The user ID to retrieve the allowed platforms for. If none is specified the
 *   currently logged in user will be used.
 * @param $reset
 *   Whether to reset the internal static cache or not.
 *
 * @todo this is not the right way. we need to implement node-level
 * access permissions here, the same way we do for sites. see
 * http://drupal.org/node/725952
 */
function _hosting_get_allowed_platforms($uid = NULL, $reset = FALSE) {
  static $platforms = array();

  if ($reset) {
    $platforms = array();
  }

  if (is_null($uid)) {
    global $user;
    $uid = $user->uid;
  }

  if (!isset($platforms[$uid])) {
    $platforms[$uid] = array();

    $result = db_query("SELECT n.nid, n.title FROM {node} n LEFT JOIN {hosting_platform} h ON n.nid = h.nid
                      LEFT JOIN {hosting_platform_client_access} p ON n.nid = p.pid
                      LEFT JOIN {hosting_client_user} c ON c.client = p.cid
                      WHERE n.type = :n.type AND n.status = :n.status AND h.status > :h.status
                      AND (c.user = :(c.user OR p.pid IS NULL)", array(':n.type' => 'platform', ':n.status' => 1, ':h.status' => HOSTING_PLATFORM_LOCKED, ':(c.user' => $uid));
    while ($server = $result->fetch()) {
      $platforms[$uid][$server->nid] = $server->title;
    }
  }
  return $platforms[$uid];
}

/**
 * Return a machine-usable name for a client.
 *
 * This aims to be usable for unix group/user names and shells.
 *
 * It adds a prefix configured in the frontend settings (defaulting to
 * 'cl-'), and strips the total length of the string (including the
 * prefix) to MAX_GROUP_LENGTH.
 *
 * This can also be used to validate user-provided client unames, as
 * it strips and readds the prefix and performs the same validation
 * and corrections on the field.
 *
 * This is inspired from the context sanitization stuff.
 *
 * @see MAX_GROUP_LENGTH
 */
function hosting_client_sanitize($title) {
  $prefix = variable_get('hosting_client_prefix', '');
  // remove anything but "word characters", dots and dashes
  // remove the prefix in case we are validating an existing uname
  // TODO: optimize in one call
  $title = preg_replace("/[!\W\.\-]/", "", preg_replace("/^$prefix/", "", $title));
  return substr(strtolower($prefix . $title), 0, MAX_GROUP_LENGTH);
}

/**
 * Implements hook_views_api().
 */
function hosting_client_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'hosting_client'),
  );
}
